<!doctype html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <title>PHP 8.2 Deque RFC Demo</title>
    <script src="//ajaxorg.github.io/ace-builds/src-min/ace.js" type="text/javascript" charset="utf-8"></script>
    <link rel="stylesheet" type="text/css" href="static/demo.css" />
    <link rel="shortcut icon" href="favicon.ico" />
</head>

<body>
    <div class="playground">
        <div class="site-header">
            <h1>PHP 8.2 <a href="https://wiki.php.net/rfc/deque">Deque RFC</a> Demo.</h1>
            <p><em>This is based on the <a href="http://github.com/phan/demo">Phan demo</a>, which is based on <a href="https://oraoto.github.io/pib/">oraoto/pib (PHP in Browser)</a></em></p>
            <p><em>(This was built on 2022-11-10 from commit <a href="https://github.com/php/php-src/pull/7500/commits/26a777de9705b31e05ac8650d097eb96f72b30ab">26a777de</a>, and <a href="https://github.com/php/php-src/pull/7500">the implementation</a> of <a href="https://wiki.php.net/rfc/deque">the RFC</a> may have changed since this was last updated.)</em></p>
            <p>(As described in Wikipedia: <em>In computer science, a <a href="https://en.wikipedia.org/wiki/Double-ended_queue"><strong>double-ended queue</strong></a> (abbreviated to <strong>deque</strong>, pronounced deck, like “cheque”) is an abstract data type that generalizes a queue, for which elements can be (efficiently) added to or removed from either the front (head) or back (tail))</em></p>
            <p><em>(Note that <a href="https://webassembly.org/">WebAssembly</a> performance/optimizations are slower and different compared to native architectures for both <a href="https://wiki.php.net/rfc/deque"><code>Collections\Deque</code></a> and <code>array</code> (and all parts of PHP). E.g. for large values of n, native x64 performance of <code>Collections\Deque</code> is several times faster than the WebAssembly performance.)</em></p>
        </div>
        <div class="playground-header">
            <!-- the js expects an analyze button to exist, it's easier to create an invisible one -->
            <button id="analyze" style="display: none;"></button>
            <div class="editor-buttons">
                <div class="button-wrapper">
                    <button id="run" title="Run PHP Code" class="disabled" disabled="disabled">Loading...</button>
                </div>
            </div>
        </div>
        <div class="playground-split-vertical">
            <div class="playground-editor">
                <div id="editor"></div>
            </div>
            <pre id="output"></pre>
        </div>
    </div>
    <a href="https://github.com/TysonAndre/php-rfc-demo"><img style="z-index: 1;position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>
<!-- TODO: move this into a generated JS file -->
    <textarea style="display:none;" id="phan_runner_source">

// This is currently unused for the enums RFC because Phan doesn't support enums yet,
// but may be useful for other rfcs
use Phan\Config;
use Phan\Issue;
use Phan\IssueInstance;
use Phan\Output\HTML;
use Phan\Output\IssuePrinterInterface;
use Symfony\Component\Console\Output\OutputInterface;


use Phan\CLI;
use Phan\Phan;
error_reporting(E_ALL);
ini_set('display_errors', 'stderr');
putenv('NO_COLOR=1');

try {
    $phar_path = 'phan-4.0.0.phar';
    if (!file_exists($phar_path)) {
        fwrite(STDERR, "Could not load '$phar_path' - this may not have been included when generating this site with emscripten\n");
        exit(1);
    }

    $phar = "phar://$phar_path";
    gc_disable();
    $data = require($phar . '/src/Phan/Language/Internal/ClassDocumentationMap.php');
    require_once($phar . '/src/requirements.php');

$code_base = require_once($phar . '/src/codebase.php');

require_once($phar . '/src/Phan/Bootstrap.php');


file_put_contents('input', $CONTENTS_TO_ANALYZE);
Config::setValue('file_list', ['input']);
// These plugins are what you'd see with --init-level=2
Config::setValue('plugins', [
    'AlwaysReturnPlugin',
    'DollarDollarPlugin',
    'DuplicateArrayKeyPlugin',
    'DuplicateExpressionPlugin',
    'PregRegexCheckerPlugin',
    'PrintfCheckerPlugin',
    'SleepCheckerPlugin',
    'UnreachableCodePlugin',
    'UseReturnValuePlugin',
    'EmptyStatementListPlugin',
    'StrictComparisonPlugin',
    'LoopVariableReusePlugin',
]);
// This is stricter, though.
Config::setValue('plugin_config', [
    'infer_pure_methods' => true,
]);

$cli = CLI::fromRawValues([
    'output-mode' => 'html',
    'allow-polyfill-parser' => false,
    'use-fallback-parser' => false,
    'redundant-condition-detection' => false,
    'dead-code-detection' => false,
    'no-progress-bar' => false,
], []);

// Analyze the file list provided via the CLI
$is_issue_found = Phan::analyzeFileList(
    $code_base,
    function (bool $recompute_file_list = false) use ($cli) : array {
        return $cli->getFileList();
    }
);
} catch (\Throwable $e) {
    echo "Caught $e\n";
}
    </textarea>
    <textarea style="display:none;" id="eval_wrapper_source">
function demo_error_handler(int $errno, string $errstr, string $errfile, int $errline) : bool {
    fwrite(STDERR, "$errfile:$errline [$errno] $errstr\n");
    ob_start();
    debug_print_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
    fwrite(STDERR, ob_get_clean());
    return false;
}
try {
    error_reporting(E_ALL);
    ini_set("display_errors", "stderr");
    set_error_handler('demo_error_handler');
    define('DEMO_FILE_CONTENTS', $CONTENTS_TO_ANALYZE);
    define('DEMO_FILE_LINES', explode("\n", $CONTENTS_TO_ANALYZE));
    eval($CONTENTS_TO_ANALYZE);
} catch (Throwable $e) {
    fwrite(STDERR, "Caught " . $e);
}
    </textarea>
    <textarea style="display:none" id="features_example">
$deque = new Collections\Deque(['first', 'second', 'third']);
foreach ($deque as $offset => $value) {
    printf("value: %6s deque[offset=%s]=%s\n", $value, $offset, $deque[$offset]);
    if ($value === 'second') {
        printf("=> Shifting while iterating: removed %s\n", $deque->shift());
    } elseif ($value === 'third') {
        printf("=> Push while iterating\n");
        $deque->push('fourth');
    }
}
echo "\nAfter iteration\n";
var_dump($deque);

function bench_array(int $n, int $iterations) {
    $startTime = hrtime(true);
    for ($i = 0; $i < $iterations; $i++) {
        $array = [];
        for ($j = 0; $j < $n; $j++) {
            array_unshift($array, $j);
        }
        $total = 0;
        for ($j = 0; $j < $n; $j++) {
            $total += array_shift($array);
        }
    }
    $elapsed = (hrtime(true) - $startTime)/1e9;
    printf("bench_array n=%7d iterations=%7d: time=%.3f seconds total=%d\n", $n, $iterations, $elapsed, $total);
    return $elapsed;
}
function bench_deque(int $n, int $iterations) {
    $startTime = hrtime(true);
    for ($i = 0; $i < $iterations; $i++) {
        $deque = new Collections\Deque();
        for ($j = 0; $j < $n; $j++) {
            $deque->unshift($j);
        }
        $total = 0;
        for ($j = 0; $j < $n; $j++) {
            $total += $deque->shift();
        }
    }
    $elapsed = (hrtime(true) - $startTime)/1e9;
    printf("bench_deque n=%7d iterations=%7d: time=%.3f seconds total=%d\n", $n, $iterations, $elapsed, $total);
    return $elapsed;
}

echo "\nBenchmark repeatedly unshifting to the front then shifting from the front.\n";
echo "This is a significantly shortened and less efficient version of https://wiki.php.net/rfc/deque#unshifting_n_values_to_the_start_then_shifting_n_values_from_the_start\n";
echo "WebAssembly performance/compiler optimizations are noticeably different from native performance (Deque is 188x faster than array natively for for me for n=2000)\n";
echo "Result preview times will differ from WebAssembly performance on your device.\n\n";
foreach ([[2000, 25], [1000, 50], [500, 100], [8, 100000]] as [$n, $iterations]) {
    $arrayTime = bench_array($n, $iterations);
    $dequeTime = bench_deque($n, $iterations);
    printf("Deque runtime for n=%7d is %.3fx faster (in WebAssembly)\n", $n, $arrayTime/$dequeTime);
    echo "\n";
}
</textarea>
<textarea style="display:none" id="precomputed_output">
value:  first deque[offset=0]=first
value: second deque[offset=1]=second
=> Shifting while iterating: removed first
value:  third deque[offset=1]=third
=> Push while iterating
value: fourth deque[offset=2]=fourth

After iteration
object(Collections\Deque)#1 (3) {
  [0]=>
  string(6) "second"
  [1]=>
  string(5) "third"
  [2]=>
  string(6) "fourth"
}

Benchmark repeatedly unshifting to the front then shifting from the front.
This is a significantly shortened and less efficient version of https://wiki.php.net/rfc/deque#unshifting_n_values_to_the_start_then_shifting_n_values_from_the_start
WebAssembly performance/compiler optimizations are noticeably different from native performance (Deque is 188x faster than array natively for for me for n=2000)
Result preview times will differ from WebAssembly performance on your device.

bench_array n=   2000 iterations=     25: time=0.534 seconds total=1999000
bench_deque n=   2000 iterations=     25: time=0.009 seconds total=1999000
Deque runtime for n=   2000 is 62.824x faster (in WebAssembly)

bench_array n=   1000 iterations=     50: time=0.278 seconds total=499500
bench_deque n=   1000 iterations=     50: time=0.009 seconds total=499500
Deque runtime for n=   1000 is 31.954x faster (in WebAssembly)

bench_array n=    500 iterations=    100: time=0.148 seconds total=124750
bench_deque n=    500 iterations=    100: time=0.009 seconds total=124750
Deque runtime for n=    500 is 16.773x faster (in WebAssembly)

bench_array n=      8 iterations= 100000: time=0.263 seconds total=28
bench_deque n=      8 iterations= 100000: time=0.180 seconds total=28
Deque runtime for n=      8 is 1.456x faster (in WebAssembly)

</textarea>
    <script type="text/javascript" src="php.js"></script>
    <script type="text/javascript" src="static/demo.js"></script>
</body>
</html>
